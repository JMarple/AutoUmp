// Auto-Ump specific implementation for the OV07740 camera

#include <xs1.h>
#include <platform.h>
#include <stdio.h>

#include "ov07740.h"
#include "sccb.h"

// All clocks used by the cameras
on tile[1]: clock camCLK = XS1_CLKBLK_1;
on tile[1]: clock sccb1CLK = XS1_CLKBLK_2;
on tile[1]: clock sccb2CLK = XS1_CLKBLK_3;
on tile[1]: clock pclk1CLK = XS1_CLKBLK_4;
on tile[1]: clock pclk2CLK = XS1_CLKBLK_5;

// Ports used by both cameras
on tile[1]: out port camRESET = XS1_PORT_1L;
//on tile[1]: out port camSFIN = XS1_PORT_4C;
on tile[1]: in  port camSYNC  = XS1_PORT_8D;

// Camera 1 Ports
on tile[1]: out port cam1XCLK = XS1_PORT_1B;
on tile[1]: in  port cam1PCLK = XS1_PORT_1A;
on tile[1]:     port cam1SCL  = XS1_PORT_1N;
on tile[1]:     port cam1SDA  = XS1_PORT_1M;
on tile[1]: in buffered port:32 cam1DATA = XS1_PORT_8A;

// Camera 2 ports
on tile[1]: out port cam2XCLK = XS1_PORT_1D;
on tile[1]: in  port cam2PCLK = XS1_PORT_1C;
on tile[1]:     port cam2SCL  = XS1_PORT_1P;
on tile[1]:     port cam2SDA  = XS1_PORT_1O;
on tile[1]: in buffered port:32 cam2DATA = XS1_PORT_8C;

const uint8_t CAM_SCCB_ID = 0x21;

// Product ID = 0x7740
const uint8_t CAM_PRODUCT_MSB = 0x0A;
const uint8_t CAM_PRODUCT_LSB = 0x0B;

// AEC/AGC
const uint8_t CAM_REG13 = 0x13;
const uint8_t CAM_GAIN = 0x00;
const uint8_t CAM_HAEC = 0x0F; // Exposure msb
const uint8_t CAM_AEC = 0x10; // Exposure lsb

// Camera size registers
// Image width (10 bits) = {CAM_HOUTSIZE[7:0], CAM_REG34[2:1]}
// Image height (9 bits) = {CAM_VOUTSIZE[7:0], CAM_REG34[0]}
const uint8_t CAM_HOUTSIZE = 0x31;
const uint8_t CAM_VOUTSIZE = 0x32;
const uint8_t CAM_REG34 = 0x34;

// AutoUmp RevA specific port bit's
// This is needed since the HREF/VSYNC's share the same
// 8-bit port for both cameras.
const uint8_t AU_HREF1 = (1 << 4);
const uint8_t AU_VSYNC1 = (1 << 5);
const uint8_t AU_HREF2 = (1 << 6);
const uint8_t AU_VSYNC2 = (1 << 7);

static void delay(uint32_t delay_amount)
{
    timer t;
    uint32_t start_time;
    t :> start_time;
    t when timerafter(start_time + delay_amount) :> void;
}

uint32_t _sync;
unsigned _count;

void testthread()
{ unsafe {

    camSYNC :> _sync;

    while (1)
    {
        select
        {
            case camSYNC when pinsneq(_sync) :> _sync:
                asm volatile ("nop\n nop\n nop\n"); // "Anti optmization"
                break;
        }
    }
}}

void waitForVSync(uint8_t x)
{
    uint32_t cur;
    camSYNC :> cur;
    while (1)
    {
       select
       {
           case camSYNC when pinsneq(cur) :> cur:
               if ((cur & AU_VSYNC1) == x) return;
               break;
       }
    }
}

unsigned waitForHREF(uint8_t x)
{
    uint32_t cur;
    unsigned count;
    camSYNC :> cur;
    while (1)
    {
        select
        {
           case camSYNC when pinsneq(cur) :> cur @ count :
               if ((cur & AU_HREF1) == x) return count;
               break;
        }
    }

    return 0;
}


uint32_t testrow[241*80];

void ov07740_capture(
        volatile uint32_t* unsafe _sync, volatile unsigned* unsafe _count,
        int vsync_bits, int href_bits, port* unsafe camDATA)
{ unsafe {
    uint8_t data, vsync = 1;
    timer t;
    uint32_t starttime, endtime;

    while (1)
    {
        waitForVSync(0);
        waitForVSync(AU_VSYNC1);
        //while ((*_sync & vsync_bits) == 0);
        //while ((*_sync & vsync_bits) > 0);

        int i = 0;
        uint32_t tmpData;

        for (int y = 0; y < 240; y++)
        {
            t :> starttime;
            unsigned count = waitForHREF(AU_HREF1);

            count += 3;

            cam1DATA @ count :> tmpData;
            testrow[y*80] = tmpData;

            for (int x = 1; x < 80; x++)
            {
                cam1DATA :> tmpData;
                testrow[y*80 + x] = tmpData;
                count += 4;
            }
            //tmpData = ov7670_capturerow(_sync, href_bits, camDATA, &(testrow[y*80]));

            //printf("data = %08x\n", tmpData);
            for (int x = 0; x < 80; x++)
            {
               // printf("x = %02d, %08x\n", x, testrow[y*80 + x]);
            }
            //printf("Data = %x\n", data);
            //while ((*_sync & href_bits) == 0);
            // taking 17 clock cycles to react?
            //uint32_t count  = *_count + 11;
            //cam1DATA @ count :> tmpData;
            //count += 4;

            //for (int x = 1; x < 80; x++)
            //{
                //cam1DATA @ count :> tmpData;
                //count += 4;
            //}
            while ((*_sync & href_bits) > 0);
        }


       // printf("i = %d %d\n", i, (endtime-starttime));

        for (int y = 0; y < 100; y++)
        {
            printf("\nRow %d\n", y);
            for (int x = 0; x < 80; x++)
                printf("%08x ", testrow[y*80+x]);
        }

        /*while ((*_sync & vsync_bits) == 0)
        {
            if ((*_sync & href_bits) > 0)
            {
               uint32_t count = *_count + 3;
               int current = 0;
               do
               {
                   uint32_t tmpData;
                   //cam1DATA @ count :> tmpData;
                   //cam2XCLK @ count <: current;
                   current = !current;
                   count+=4;
               } while ((*_sync & href_bits) > 0);
               i++;
            }
        }*/

    }
}}

void launchCameras()
{ unsafe {
    hwlock_t hwlock;
    hwlock = hwlock_alloc();

    void* unsafe sync = (void* unsafe)&camSYNC;

    volatile uint32_t* unsafe psync = (uint32_t* unsafe)&_sync;
    volatile unsigned* unsafe pcount = (unsigned* unsafe)&_count;

    par
    {
        //testthread();
        ov07740_capture(psync, pcount,
            AU_VSYNC1, AU_HREF1, (port* unsafe)&cam1DATA);
        //ov07740_capture(psync, pcount,
        //    AU_VSYNC2, AU_HREF2, (port* unsafe)&cam2DATA);
    }

    while (1==1);
}}

int configureCams()
{ unsafe {

    // Reset all registers to default values.
    sccb_wr(CAM_SCCB_ID, 0x12, 0b10000000, cam1SCL, cam1SDA);
    sccb_wr(CAM_SCCB_ID, 0x12, 0b10000000, cam2SCL, cam2SDA);

    // Allow the sensor to reset, delays for 50ms
    delay(5000000);

    // Iterate through the register/value pairs and write them
    // to the sensor.
    for (int i = 0; i < sizeof(OV7740_QVGA)/sizeof(struct SCCBPairs); i++)
    {
        sccb_wr(CAM_SCCB_ID,
            OV7740_QVGA[i].reg,
            OV7740_QVGA[i].value,
            cam1SCL, cam1SDA);

        sccb_wr(CAM_SCCB_ID,
            OV7740_QVGA[i].reg,
            OV7740_QVGA[i].value,
            cam2SCL, cam2SDA);
    }

    // Delay to let allow a few frames to go by
    delay(5000000);

    return 1;
}}

int initCams()
{ unsafe {
    // Configure output clock to both cameras.
    configure_clock_rate(camCLK, 100, 16);
    configure_port_clock_output(cam1XCLK, camCLK);
    //configure_port_clock_output(cam2XCLK, camCLK);
    start_clock(camCLK);

    // Configured pixel input clock
    configure_clock_src(pclk1CLK, cam1PCLK);
    configure_in_port(cam1DATA, pclk1CLK);
    configure_in_port(camSYNC, pclk1CLK);
    start_clock(pclk1CLK);

    configure_clock_src(pclk2CLK, cam2PCLK);
    configure_in_port(cam2DATA, pclk2CLK);
    start_clock(pclk2CLK);

    // Take the cameras out of reset
    camRESET <: 1;

    // Initialize SCCB Bus for both cameras
    sccb_init(cam1SDA, cam1SCL, sccb1CLK);
    sccb_init(cam2SDA, cam2SCL, sccb2CLK);

    // First `scccb_rd` always returns 0xFF for some reason.
    // TODO: Fix this bug
    sccb_rd(CAM_SCCB_ID, 0x00, cam1SCL, cam1SDA);

    // Get Product ID from cam1
    int msb1 = sccb_rd(CAM_SCCB_ID, CAM_PRODUCT_MSB, cam1SCL, cam1SDA);
    int lsb1 = sccb_rd(CAM_SCCB_ID, CAM_PRODUCT_LSB, cam1SCL, cam1SDA);

    // Get Product ID from cam2
    int msb2 = sccb_rd(CAM_SCCB_ID, CAM_PRODUCT_MSB, cam2SCL, cam2SDA);
    int lsb2 = sccb_rd(CAM_SCCB_ID, CAM_PRODUCT_LSB, cam2SCL, cam2SDA);

    int returnVal = 0;

    if (msb1 == 0x77 && lsb1 == 0x40) returnVal += 0b01;
    if (msb2 == 0x77 && lsb2 == 0x40) returnVal += 0b10;

    return returnVal;
}}

/*static inline int _getSYNC(port* unsafe psync, hwlock_t hwlock, int bit)
{ unsafe {

    uint32_t data;

    // A lock is used to ensure the port isn't accessed
    // at the same time by another core.
    // An "ET_RESOURCE_DEP, Resource dependency exception" will
    // be thrown if multiple cores try to access this resource!
    hwlock_acquire(hwlock);
    (*psync) :> data;
    hwlock_release(hwlock);

    return data & bit;
}}*/
