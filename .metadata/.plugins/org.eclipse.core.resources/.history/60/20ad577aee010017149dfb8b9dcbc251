/*
    Implements a queue (FIFO) using a circular buffer.
*/
#include <stdint.h>
#include <stdio.h>
#include <inttypes.h>
#include "queue.h"
#include "CuTest.h"

void queueInit(struct Queue* q)
{
    q->head    = 0;
    q->tail    = 0;
    q->numElem = 0;
    for(int i = 0; i < BUFFER_SIZE; i++)
    {
        q->arr[i] = 0;
    }
}

uint32_t queueEnqueue(struct Queue* q, uint32_t val)
{
    if(q->numElem == BUFFER_SIZE)
    {
        return QUEUE_FULL;
    }

    q->arr[q->tail] = val;
    q->tail = (q->tail + 1) % BUFFER_SIZE;
    q->numElem++;

    return 0;
}

uint32_t queueDequeue(struct Queue* q)
{
    if(q->numElem <= 0)
    {
        return NO_ELEM_IN_QUEUE;
    }

    uint16_t temp = q->arr[q->head];
    q->head = (q->head + 1) % BUFFER_SIZE;
    q->numElem--;
    return temp;
}

uint32_t queuePeek(struct Queue* q)
{
    if(q->numElem <= 0)
    {
        return NO_ELEM_IN_QUEUE;
    }

    return q->arr[q->head];
}

uint8_t queueIsEmpty(struct Queue* q)
{
    if(q->numElem == 0)
    {
        return 1;
    }
    else return 0;
}

// printQueue doesn't alter the queue itself.
void queuePrint(struct Queue* q)
{
    printf("Printing Queue from head to tail:\n");
    uint16_t num = q->numElem;
    uint16_t head = q->head;
    while(num > 0)
    {
        printf("queue val: %"PRIi32" \n", q->arr[head]);
        head = (head + 1) % BUFFER_SIZE;
        num--;
    }
}


/*
------ QUEUE TESTS -----
Here is what we need to test: (from http://cs.lmu.edu/~ray/notes/queues/)

A queue is empty on initialization
A queue has size 0 on initialization
After n enqueues to an empty queue, n > 0, the queue is not empty and its size is n
If one enqueues x then dequeues, the value dequeued is x.
If one enqueues x then peeks, the value returned is x, but the size stays the same
If the size is n, then after n dequeues, the stack is empty and has a size 0
If one enqueues the values 1 through 50, in order, into an empty queue, then if 50 dequeues are done the values dequeues are 1 through 50.
Dequeueing from an empty queue returns NO_ELEM_IN_QUEUE
Peeking into an empty queue does returns NO_ELEM_IN_QUEUE
For bounded queues only, pushing onto a full stack results in returning QUEUE_FULL
*/

/*
void testNewQueueIsEmpty(CuTest *tc)
{
    struct Queue q;
    queueInit(&q);

    CuAssertIntEquals(tc, 0, q.numElem);
    CuAssertIntEquals(tc, 1, queueIsEmpty(&q));
}

void testInsertToEmptyQueue(CuTest *tc)
{
    struct Queue q;
    queueInit(&q);

    queueEnqueue(&q, 5);
    uint32_t val = queuePeek(&q);
    CuAssertIntEquals(tc, 1, q.numElem);
    CuAssertIntEquals(tc, 5, val);
}

void testEnqueueThenDequeue(CuTest *tc)
{
    struct Queue q;
    queueInit(&q);

    queueEnqueue(&q, 1000);
    CuAssertIntEquals(tc, 1, q.numElem);
    uint32_t val = queueDequeue(&q);
    CuAssertIntEquals(tc, 1000, val);
    CuAssertIntEquals(tc, 0, q.numElem);
}

void testEnqueueThenPeek(CuTest *tc)
{
    struct Queue q;
    queueInit(&q);

    queueEnqueue(&q, 500);
    uint32_t val = queuePeek(&q);

    CuAssertIntEquals(tc, 500, val);
}

void testRemoveUntilEmpty(CuTest *tc)
{
    struct Queue q;
    queueInit(&q);

    uint32_t temp;

    for(int i = 0; i < 50; i++)
    {
        queueEnqueue(&q, i);
    }

    for(int i = 0; i < 50; i++)
    {
        temp = queueDequeue(&q);
    }

    CuAssertIntEquals(tc, 0, q.numElem);
    CuAssertTrue(tc, queueIsEmpty(&q) == 1);
}

void testFiftyInThenFiftyOut(CuTest *tc)
{
    struct Queue q;
    queueInit(&q);

    uint32_t temp;

    for(int i = 0; i < 50; i++)
    {
        queueEnqueue(&q, i);
    }

    queuePrint(&q);

    for(int i = 0; i < 50; i++)
    {
        temp = queueDequeue(&q);
        CuAssertIntEquals(tc, i, temp);
    }

    CuAssertIntEquals(tc, 0, q.numElem);
    CuAssertTrue(tc, queueIsEmpty(&q) == 1);
}

void testDequeueFromEmpty(CuTest *tc)
{
    struct Queue q;
    queueInit(&q);

    uint32_t val = queueDequeue(&q);
    CuAssertIntEquals(tc, NO_ELEM_IN_QUEUE, val);
}

void testPeekIntoEmpty(CuTest *tc)
{
    struct Queue q;
    queueInit(&q);

    uint32_t val = queuePeek(&q);
    CuAssertIntEquals(tc, NO_ELEM_IN_QUEUE, val);
}

void testEnqueueOntoFull(CuTest *tc)
{
    struct Queue q;
    queueInit(&q);

    for(int i = 0; i < BUFFER_SIZE; i++)
    {
        queueEnqueue(&q, i);
    }

    uint32_t val = queueEnqueue(&q, 0);
    CuAssertIntEquals(tc, val, QUEUE_FULL);
}


CuSuite* queueGetSuite()
{
    CuSuite* suite = CuSuiteNew();
    SUITE_ADD_TEST(suite, testNewQueueIsEmpty);
    SUITE_ADD_TEST(suite, testInsertToEmptyQueue);
    SUITE_ADD_TEST(suite, testEnqueueThenDequeue);
    SUITE_ADD_TEST(suite, testEnqueueThenPeek);
    SUITE_ADD_TEST(suite, testRemoveUntilEmpty);
    SUITE_ADD_TEST(suite, testFiftyInThenFiftyOut);
    SUITE_ADD_TEST(suite, testDequeueFromEmpty);
    SUITE_ADD_TEST(suite, testPeekIntoEmpty);
    SUITE_ADD_TEST(suite, testEnqueueOntoFull);
    return suite;
}*/
