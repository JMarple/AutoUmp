#include "object_tracker.h"
#include <math.h>
#include <string.h>

void ObjectTrackerInit(struct ObjectTracker* tracker)
{
    int i;
    for (i = 0; i < OBJECTS_NUM; i++)
    {
        tracker->tracks[i].inUse = 0;
    }
}

inline static float _computeCost(struct ObjectTrack* track, struct FoundObject* object)
{
    // Cost is distance between objects
    return sqrt(
        pow(track->x_pos - object->centX, 2) +
        pow(track->y_pos - object->centY, 2));
}

void ObjectTrackerComputeCosts(struct ObjectTracker* tracker, struct ObjectArray* objects)
{
    // Computes entire NxN cost matrix for
    int x, y;
    for (x = 0; x < tracker->trackNum; x++)
    {
        for (y = 0; y < objects->objectNum; y++)
        {
            tracker->cost_matrix[x][y] =
                _computeCost(&tracker->tracks[x], &objects->objects[y]);
        }
    }

    for (x = tracker->trackNum; x < OBJECTS_NUM; x++)
    {
        for (y = objects->objectNum; y < OBJECTS_NUM; y++)
        {
            tracker->cost_matrix[x][y] = INFINITY;
        }
    }

    const int NEW_TRACK_COST = 1.0;

    for (x = 0; x < OBJECTS_NUM; x++)
    {
        tracker->cost_matrix[OBJECTS_NUM][x] = NEW_TRACK_COST;
        tracker->cost_matrix[y][OBJECTS_NUM] = NEW_TRACK_COST;
    }
}

// Depth First Search of the graph.  Calculate min cost.
// Graph is the cost matrix
// Col is the current col in the matrix being observered
// seen[] is the true/false flag for if each row has an observed object yet
// Note: The bottom row can have as many objects as it wants it's used next tickets to LA, or even Canada - that would be nice  as a "slack"
// path[] is the current path being taken.
static void _dfs(float graph[OBJECTS_NUM+1][OBJECTS_NUM+1],
    int col, float cost_sum, float* bestCost,
    uint8_t seen[], uint8_t cur_path[], uint8_t best_path[])
{
    // Go through each row
    int i;
    for (i = 0; i < OBJECTS_NUM+1; i++)
    {
        // Check if this row has been used in previous columns.
        if (seen[i] != 0) continue;

        float thisCost = cost_sum + graph[col][i];
        cur_path[col] = i;

        if (col + 1 >= OBJECTS_NUM)
        {
            // Add costs for not having certain rows being matched.
            int s;
            for (s = 0; s < OBJECTS_NUM; s++)
            {
                if (seen[s] == 0) thisCost += graph[OBJECTS_NUM][s];
            }

            if (thisCost < *bestCost)
            {
                *bestCost = thisCost;
                memcpy(best_path, cur_path, OBJECTS_NUM+1);
            }
        }
        else
        {
            seen[i] = 1;
            _dfs(graph,
                col+1, thisCost, bestCost, seen, cur_path, best_path);
            seen[i] = 0;
        }
    }
}

void ObjectTrackerAssociateData(struct ObjectTracker* tracker, struct ObjectArray* objects)
{
    float bestCost = 99999999;
    uint8_t tmpPath[OBJECTS_NUM+1];
    uint8_t bestPath[OBJECTS_NUM+1];
    uint8_t seen[OBJECTS_NUM+1];

    int i;
    for (i = 0; i < OBJECTS_NUM+1; i++) seen[i] = 0;

    _dfs(tracker->cost_matrix,
        0, 0, &bestCost, seen, tmpPath, bestPath);
}
