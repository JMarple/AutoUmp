	.globl ov7670_capturerow
	.globl ov7670_capturerow.nstackwords
	.linkset ov7670_capturerow.nstackwords, 10
	.align 4
	.issue_mode dual

// r0 is the pointer to the 320x240 buffer
// r1 is the pointer to the bit buffer
// r2 is the data port
// r3 is the sync port
ov7670_captureimage:
	dualentsp 9

	// Save register states
	stw r4, sp[1]
	stw r5, sp[2]
	stw r6, sp[3]
	stw r7, sp[4]
	stw r8, sp[5]
	stw r9, sp[6]
	stw r10, sp[7]
	stw r11, sp[8]

	#define byteBufPtr r0
	#define bitBufPtr  r1
	#define dataPort r2
	#define syncPort r3
	#define syncVal  r4
	#define y        r5
	#define x        r6

	#define hrefMask r7
	#define countVal r8


	ldc y, 0
	ldc x, 0
	ldc r10, 318
	rowsLoop:

		// Wait for HREF to go high
		in syncVal, res[syncPort]
		clre
		eeu res[syncPort]
		setc res[syncPort], 0x19
		ldap r11, checkIfHREFHigh
		setv res[syncPort], r11

		waitForHREFHigh:
			setd res[syncPort], syncVal
			waiteu

		checkIfHREFHigh:
			getts countVal, res[syncPort]
			{in syncVal, res[syncPort]; ldc hrefMask, 0x10}
			and r11, syncVal, hrefMask
			bf r11, waitForHREFHigh

		// Wait 7 clock ticks and get first pixels
		add countVal, countVal, 0x7
		setpt res[dataPort], r7
		setc res[dataPort], 0x1

		// Start gathering all the row's data
		#undef countVal
		#undef hrefMask
		#undef syncVal
		#define dataVal r4

		dataloop:
			in dataVal, res[dataPort]

			// Data is extracted to r7 & r8
			{shr r7, dataVal, 8; shr r8, dataVal, 24}

			// Save data to bs buffer
			{st8 r7, byteBufPtr, r5; add r5, r5, 1}
			{st8 r8, byteBufPtr, r5; add r5, r5, 1}

			remu r7, r5, r10
			bf r7, dataloop

		// GO BACK TO ROWSLOOP

	// Setup Event
	// r4 is the original state of the port
	// r6 is the bit mask being applied to the port
	/*setc res[r3], 0x1
	in r4, res[r1]

	clre
	eeu res[r3]
	setc res[r3], 0x19
	ldap r11, checkForVSYNCLow
	setv res[r3], r11
	setd res[r3], r4

	// Wait for VSYNC to go low
	waitForVSYNCLow:
		setd res[r3], r4
		waiteu

	checkForVSYNCLow:
		in r5, res[r3]
		and r11, r5,*/


	// Return
	ldw r4, sp[1]
	ldw r5, sp[2]
	ldw r6, sp[3]
	ldw r7, sp[4]
	ldw r8, sp[5]
	ldw r9, sp[6]
	ldw r10, sp[7]
	ldw r11, sp[8]
	retsp 9

// r0 is pointer to _sync variable
// r1 is the href_bits mask
// r2 is the cam#DATA port pointer
// r3 is the buffer to save to
ov7670_capturerow:
	dualentsp 6

	// Save register states
	stw r4, sp[1]
	stw r5, sp[2]
	stw r6, sp[3]
	stw r7, sp[4]
	stw r8, sp[5]

	ldw r2, r2[0x00]
	ldc r4, 0x00
	ldc r5, 0x00
	ldc r6, 0x00
	ldc r7, 5

    /*
    The sync thread compiles to this.
     -> reads input from sync port
     -> saves data to '_sync'
    Takes 2 clock cyles for the data to be saved.
    .label9  0x000403b4: c4 b6:       in (2r)         r1, res[r0]
             0x000403b8: 00 f0 6b 50: stw (lru6)      r1, dp[0x2b]
	*/

	// This loop allows us to know exactly when
	// the variable was changed in clock ticks.
	// load -> bf -> and -> bf
	// Exactly 4 cycles since variable change.
	while_href_low:
		{ldw r5, r0[0x00]; and r4, r5, r1}
		bf r4, while_href_low;

/*
 	On input, the shift register will become full if the processor does not input data to empty
		the transfer register;
	when the processor inputs the data, the transfer register is filled from the shift register
		and the shift register will start to be re-filled from the pins.
*/

 	// At this point, 6 clock cyles has gone by since
 	// the signal changed.
	x_pixels_loop:
		in r0, res[r2]
		stw r0, r3[r6]
		add r6, r6, 1
		lss r8, r6, r7
		bt r8, x_pixels_loop;

	// Return
	ldw r4, sp[1]
	ldw r5, sp[2]
	ldw r6, sp[3]
	ldw r7, sp[4]
	ldw r8, sp[5]
	retsp 6

// r0 is port* sync
// r1 is hwlock
// r2 is the bit-mask
/*ov7670_cap:
	dualentsp 1

	ldw r0, r0[0x00]

	// While vsync/href is low
	cap1:
		// Aquire lock
		in r1, res[r1]

		// Read sync
		in r3, res[r0]

		// Release lock
		{out res[r1], r1; and r3, r3, r2}

		bf r3, cap1

	// While vsync/href is high
	cap2:
		in r1, res[r1]
		in r3, res[r0]
		{out res[r1], r1; and r3, r3, r2}
		bt r3, cap2

	retsp 1*/

/*
.label8  0x000403ec: e0 8f:       gettime (1r)    r0
         0x000403ee: ff 17:       nop (0r)
         0x000403f0: c0 b7:       in (2r)         r4, res[r4]
         0x000403f2: ff 17:       nop (0r)
         0x000403f4: ff 17:       nop (0r)
         0x000403f6: d4 08:       ldw (2rus)      r1, r5[0x0]
         0x000403f8: 41 e8:       setc (ru6)      res[r1], 0x1
         0x000403fa: ff 17:       nop (0r)
         0x000403fc: c5 b6:       in (2r)         r1, res[r1]
         0x000403fe: ff 17:       nop (0r)
         0x00040400: c0 af:       out (r2r)       res[r4], r4
         0x00040402: ff 17:       nop (0r)
         0x00040404: 67 3a:       and (3r)        r2, r1, r7
         0x00040406: e1 8f:       gettime (1r)    r1
         0x00040408: 00 f0 88 7c: bf (lru6)       r2, -0x8 <.label8>
         */
